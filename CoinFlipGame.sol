// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.7.0 <0.9.0;

contract CoinFlip {

    //admin address
    address adminAddress;

    // use of big number to divide with random generated by vrf for getting value of head and tail
    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;

    //address array contains the List of all the bets happens
    address[] List;
    //used to give serial number to List array
    uint256 count;
    //used to give serial number to completedBets
    uint256 completedBets_no;

    //used to check is it is the first bet of user if true then give 100tokens 
    mapping(address => bool ) is_first_bet;
    //store the balance of user mapped with address
    mapping(address => uint256)  balanceOf;
    //amount of bet that betted by user
    mapping(address => uint256) address_to_amount;
    //used to check is user already part of any bet
    mapping(address => bool) is_already_betted;
    //store the bet value 0/1 as head/tail enter by user
    mapping(address => bool) bet_value;

    //containing mapping value of address and amount to win/loss of completed bets
    mapping(uint256 => mapping(address => uint256)) public completedBets;

    //event emited after every win
    event Done(address indexed _gamblerAddresss , uint256 _amount);

    //runs at the time of deployment
    constructor() payable {
        balanceOf[msg.sender] = 100;
        count = 0;
        completedBets_no = 0;
        adminAddress = msg.sender;
    }

    //genrate random number 
    function vrf() public view returns (bytes32 result) {
        uint[1] memory bn;
        bn[0] = block.number;
        assembly {
        let memPtr := mload(0x40)
        if iszero(staticcall(not(0), 0xff, bn, 0x20, memPtr, 0x20)) {
            invalid()
        }
        result := mload(memPtr)
        }
    }

    function transferFrom(address _from , address _to , uint256 _value) private  {
        //Exception if account doesnot have enough
        require(balanceOf[_from] >= _value);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
    }

    //Reward the bets , take random number from vrf and genrate 0/1 head/tail then compare with user's bet if mathes then money tranferred to user address account 
    function rewardBets() public payable {
        uint coinFlip = uint256(vrf())/FACTOR;
        bool guess = coinFlip == 1 ? true : false;
        for(uint256 i = 0 ;i<List.length ; i++) {
            if(bet_value[List[i]]==guess) {
                transferFrom(adminAddress , List[i] , 2*address_to_amount[List[i]]);
                emit Done(List[i] , address_to_amount[List[i]]);
                completedBets[completedBets_no][List[i]] = address_to_amount[List[i]]; 
            }else {
                completedBets[completedBets_no][List[i]] =0; 
            }
            completedBets_no=completedBets_no+1;
            is_already_betted[List[i]]=false;
            address_to_amount[List[i]]=0;
        }
        count =0;
    }

    //user can able to bet by adding amount and the bet value head/tail 0/1
    function place_a_bet(uint256 _amount , bool _value)  public payable {
        //if first bet of user then add 100 to their account
        if(!is_first_bet[msg.sender]) {
            balanceOf[msg.sender] = 100;
            is_first_bet[msg.sender] =true;
        }
        //check for enough balance
        require(balanceOf[msg.sender] >= _amount , "You have not enough amount!!");
        //check if already part of any bet
        require(is_already_betted[msg.sender]!=true , "You have already betted");
        List[count] = msg.sender;
        count = count +1;
        //deduct the amount
        // balanceOf[msg.sender] -= _amount;
        transferFrom(msg.sender , adminAddress , _amount);
        is_already_betted[msg.sender] = true;
        address_to_amount[msg.sender] = _amount;
        bet_value[msg.sender] = _value;
    }
}
